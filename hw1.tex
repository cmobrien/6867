\documentclass[12pt]{article}

\usepackage{amsmath}    % need for subequations
\usepackage{graphicx}   % need for figures
\usepackage{verbatim}   % useful for program listings
\usepackage{color}      % use if color is used in text
\usepackage{subfigure}  % use for side-by-side figures
\usepackage{hyperref}   % use for hypertext links, including those to external documents and URLs

\begin{document}

\section{Problem 1}

\subsection{Part 1}

See attached code.

\subsection{Part 2}

Choosing a starting guess that is close to a solution will make the function converge more quickly. Choosing a starting guess that's on a downward slope into a particular solution will probably make the ultimate result of gradient descent be that solution; therefore, you'll get a better solution if the starting guess is on a downward slope into a global maximum, and a worse solution if the starting guess is on a downward slope into a mediocre local maximum.

A lower step size will make the function yield better results but also converge more slowly.

A lower convergence criterion will make the function yield better results but also converge more slowly. Also, a low convergence criterion combine with a high step size could create the risk that the process will never terminate.

\subsection{Part 3}

See attached code.

\subsection{Part 4}

Our gradient descent procedure, with a step size of 0.1 and convergence criterion of 0.1, took 360 function calls to converge to the correct solution in the quadratic bowl, whereas the scipy optimizer fmin_bfgs took 16 function calls. When we increased the step size and convergence criterion to 1, our procedure instead took 30 function calls; however, this number is somewhat misleading, because had we chosen the initial guess (or the solution!) to not be integers, our algorithm would have converged to a substantially inferior result. Moreover, as we made the initial guess be farther and farther from the true solution, our optimizer took longer and longer to converge, whereas the scipy optimizer did not use more function calls. It would seem, therefore, that the scipy optimizer is much faster and more effective than our optimizer, particularly for guesses distant from the solution.

\section{Problem 2}

\subsection{Part 1}

See attached code.

\subsection{Part 2}

See attached code.

\subsection{Part 3}

% NEEDS WRITING

\section{Problem 3}

\subsection{Part 1}

% NEEDS WRITING

\subsection{Part 2}

% NEEDS WRITING

\subsection{Part 3}

% NEEDS WRITING

\section{Problem 4}

\subsection{Part 1}

% NEEDS WRITING

\subsection{Part 2}

% NEEDS WRITING

\subsection{Part 3}

The difference in approaches in the previous two questions (in other words, punishing error linearly versus punishing error quadratically) is reflected in the different way the two approaches handle outliers. If you expected your data to have a lot of outliers that you don't think accurately reflect  the future correct answers, you should probably use absolute deviations. If your data is generally pretty clumped, with few misleading outliers, you probably want squared deviations, because otherwise you run the risk that some of your data points might not get as much weight as they deserve. 

You might want to use the lasso when you have a lot of features and you want to ignore some of them entirely. Linear punishment will push many of the weights all the way to 0, and then your function will be simple to explain, implement, and think about intuitively.

If your prediction problem has absolute value loss, it becomes likelier that you'll want to use the method from 4-1, which seeks to minimize the absolute differences between prediction and result rather than the squared difference between prediction and result. This is because presumably you want to train your predictor in such a way that it minimizes the loss function that you will suffer when you use your predictor on real data. How much you punish high weight vectors, on the other hand, is more about how scared you are of overfitting than it is about the details of your loss function; an unusual loss function is unlikely to make you change how much and in what way you punish high weights.

\end{document}